//
// Generated by Bluespec Compiler, version 2022.01 (build 066c7a8)
//
// On Wed Apr 27 11:32:37 UTC 2022
//
//
// Ports:
// Name                         I/O  size props
// drp_addr                       O    11 const
// drp_en                         O     1 reg
// drp_do                         O    16 const
// drp_we                         O     1 reg
// msix_vectors_per_pf0           O    32 const
// msix_vectors_per_pf1           O    32 const
// msix_vectors_per_pf2           O    32 const
// msix_vectors_per_pf3           O    32 const
// msix_vectors_per_vfg0          O    32 const
// msix_vectors_per_vfg1          O    32 const
// msix_vectors_per_vfg2          O    32 const
// msix_vectors_per_vfg3          O    32 const
// numvec_valid                   O     1 reg
// dma_resetn                     O     1 reg
// clk                            I     1 clock
// resetn                         I     1 reset
// drp_rdy                        I     1 reg
// drp_di                         I    16 unused
// numvec_done                    I     1 reg
// start_reset                    I     1 reg
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkQDMAConfigurator(clk,
			  resetn,

			  drp_addr,

			  drp_en,

			  drp_do,

			  drp_we,

			  drp_rdy,

			  drp_di,

			  msix_vectors_per_pf0,

			  msix_vectors_per_pf1,

			  msix_vectors_per_pf2,

			  msix_vectors_per_pf3,

			  msix_vectors_per_vfg0,

			  msix_vectors_per_vfg1,

			  msix_vectors_per_vfg2,

			  msix_vectors_per_vfg3,

			  numvec_valid,

			  numvec_done,

			  start_reset,

			  dma_resetn);
  input  clk;
  input  resetn;

  // value method drp_drp_addr
  output [10 : 0] drp_addr;

  // value method drp_drp_en
  output drp_en;

  // value method drp_drp_do
  output [15 : 0] drp_do;

  // value method drp_drp_we
  output drp_we;

  // action method drp_get_rdy
  input  drp_rdy;

  // action method drp_get_di
  input  [15 : 0] drp_di;

  // value method msix_vec_ctrl_msix_vectors_per_pf0
  output [31 : 0] msix_vectors_per_pf0;

  // value method msix_vec_ctrl_msix_vectors_per_pf1
  output [31 : 0] msix_vectors_per_pf1;

  // value method msix_vec_ctrl_msix_vectors_per_pf2
  output [31 : 0] msix_vectors_per_pf2;

  // value method msix_vec_ctrl_msix_vectors_per_pf3
  output [31 : 0] msix_vectors_per_pf3;

  // value method msix_vec_ctrl_msix_vectors_per_vfg0
  output [31 : 0] msix_vectors_per_vfg0;

  // value method msix_vec_ctrl_msix_vectors_per_vfg1
  output [31 : 0] msix_vectors_per_vfg1;

  // value method msix_vec_ctrl_msix_vectors_per_vfg2
  output [31 : 0] msix_vectors_per_vfg2;

  // value method msix_vec_ctrl_msix_vectors_per_vfg3
  output [31 : 0] msix_vectors_per_vfg3;

  // value method msix_vec_ctrl_numvec_valid
  output numvec_valid;

  // action method msix_vec_ctrl_acceptDone
  input  numvec_done;

  // action method trigger
  input  start_reset;

  // value method dma_resetn
  output dma_resetn;

  // signals for module outputs
  wire [31 : 0] msix_vectors_per_pf0,
		msix_vectors_per_pf1,
		msix_vectors_per_pf2,
		msix_vectors_per_pf3,
		msix_vectors_per_vfg0,
		msix_vectors_per_vfg1,
		msix_vectors_per_vfg2,
		msix_vectors_per_vfg3;
  wire [15 : 0] drp_do;
  wire [10 : 0] drp_addr;
  wire dma_resetn, drp_en, drp_we, numvec_valid;

  // register count
  reg [7 : 0] count;
  reg [7 : 0] count$D_IN;
  wire count$EN;

  // register dmaResetN
  reg dmaResetN;
  wire dmaResetN$D_IN, dmaResetN$EN;

  // register drpEn
  reg drpEn;
  wire drpEn$D_IN, drpEn$EN;

  // register drpRdy
  reg drpRdy;
  wire drpRdy$D_IN, drpRdy$EN;

  // register drpState
  reg [1 : 0] drpState;
  reg [1 : 0] drpState$D_IN;
  wire drpState$EN;

  // register drpWE
  reg drpWE;
  wire drpWE$D_IN, drpWE$EN;

  // register numvecDone
  reg numvecDone;
  wire numvecDone$D_IN, numvecDone$EN;

  // register numvecValid
  reg numvecValid;
  wire numvecValid$D_IN, numvecValid$EN;

  // register startReset
  reg startReset;
  wire startReset$D_IN, startReset$EN;

  // register vecState
  reg [1 : 0] vecState;
  reg [1 : 0] vecState$D_IN;
  wire vecState$EN;

  // rule scheduling signals
  wire WILL_FIRE_RL_finishDrpWrite,
       WILL_FIRE_RL_finishResetCycle,
       WILL_FIRE_RL_startResetCycle;

  // inputs to muxes for submodule ports
  wire [7 : 0] MUX_count$write_1__VAL_1, MUX_count$write_1__VAL_2;
  wire MUX_count$write_1__SEL_1,
       MUX_dmaResetN$write_1__SEL_1,
       MUX_numvecValid$write_1__SEL_1;

  // remaining internal signals
  wire count_2_ULT_128___d13, count_2_ULT_16___d18;

  // value method drp_drp_addr
  assign drp_addr = 11'd213 ;

  // value method drp_drp_en
  assign drp_en = drpEn ;

  // value method drp_drp_do
  assign drp_do = 16'd255 ;

  // value method drp_drp_we
  assign drp_we = drpWE ;

  // value method msix_vec_ctrl_msix_vectors_per_pf0
  assign msix_vectors_per_pf0 = 32'd256 ;

  // value method msix_vec_ctrl_msix_vectors_per_pf1
  assign msix_vectors_per_pf1 = 32'd0 ;

  // value method msix_vec_ctrl_msix_vectors_per_pf2
  assign msix_vectors_per_pf2 = 32'd0 ;

  // value method msix_vec_ctrl_msix_vectors_per_pf3
  assign msix_vectors_per_pf3 = 32'd0 ;

  // value method msix_vec_ctrl_msix_vectors_per_vfg0
  assign msix_vectors_per_vfg0 = 32'd0 ;

  // value method msix_vec_ctrl_msix_vectors_per_vfg1
  assign msix_vectors_per_vfg1 = 32'd0 ;

  // value method msix_vec_ctrl_msix_vectors_per_vfg2
  assign msix_vectors_per_vfg2 = 32'd0 ;

  // value method msix_vec_ctrl_msix_vectors_per_vfg3
  assign msix_vectors_per_vfg3 = 32'd0 ;

  // value method msix_vec_ctrl_numvec_valid
  assign numvec_valid = numvecValid ;

  // value method dma_resetn
  assign dma_resetn = dmaResetN ;

  // rule RL_finishDrpWrite
  assign WILL_FIRE_RL_finishDrpWrite = drpState == 2'd2 && drpRdy ;

  // rule RL_startResetCycle
  assign WILL_FIRE_RL_startResetCycle = vecState == 2'd0 && startReset ;

  // rule RL_finishResetCycle
  assign WILL_FIRE_RL_finishResetCycle = vecState == 2'd3 && numvecDone ;

  // inputs to muxes for submodule ports
  assign MUX_count$write_1__SEL_1 = vecState == 2'd2 && count_2_ULT_16___d18 ;
  assign MUX_dmaResetN$write_1__SEL_1 =
	     vecState == 2'd1 && !count_2_ULT_128___d13 ;
  assign MUX_numvecValid$write_1__SEL_1 =
	     vecState == 2'd2 && !count_2_ULT_16___d18 ;
  assign MUX_count$write_1__VAL_1 = count + 8'd1 ;
  assign MUX_count$write_1__VAL_2 =
	     count_2_ULT_128___d13 ? count + 8'd1 : 8'd0 ;

  // register count
  always@(MUX_count$write_1__SEL_1 or
	  MUX_count$write_1__VAL_1 or
	  vecState or
	  MUX_count$write_1__VAL_2 or WILL_FIRE_RL_startResetCycle)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_count$write_1__SEL_1: count$D_IN = MUX_count$write_1__VAL_1;
      vecState == 2'd1: count$D_IN = MUX_count$write_1__VAL_2;
      WILL_FIRE_RL_startResetCycle: count$D_IN = 8'd0;
      default: count$D_IN = 8'b10101010 /* unspecified value */ ;
    endcase
  end
  assign count$EN =
	     vecState == 2'd2 && count_2_ULT_16___d18 || vecState == 2'd1 ||
	     WILL_FIRE_RL_startResetCycle ;

  // register dmaResetN
  assign dmaResetN$D_IN = MUX_dmaResetN$write_1__SEL_1 ;
  assign dmaResetN$EN =
	     vecState == 2'd1 && !count_2_ULT_128___d13 ||
	     WILL_FIRE_RL_startResetCycle ;

  // register drpEn
  assign drpEn$D_IN = drpState != 2'd1 ;
  assign drpEn$EN = drpState == 2'd1 || drpState == 2'd0 ;

  // register drpRdy
  assign drpRdy$D_IN = drp_rdy ;
  assign drpRdy$EN = 1'd1 ;

  // register drpState
  always@(drpState or WILL_FIRE_RL_finishDrpWrite)
  begin
    case (1'b1) // synopsys parallel_case
      drpState == 2'd0: drpState$D_IN = 2'd1;
      drpState == 2'd1: drpState$D_IN = 2'd2;
      WILL_FIRE_RL_finishDrpWrite: drpState$D_IN = 2'd3;
      default: drpState$D_IN = 2'b10 /* unspecified value */ ;
    endcase
  end
  assign drpState$EN =
	     drpState == 2'd0 || drpState == 2'd1 ||
	     WILL_FIRE_RL_finishDrpWrite ;

  // register drpWE
  assign drpWE$D_IN = drpState != 2'd1 ;
  assign drpWE$EN = drpState == 2'd1 || drpState == 2'd0 ;

  // register numvecDone
  assign numvecDone$D_IN = numvec_done ;
  assign numvecDone$EN = 1'd1 ;

  // register numvecValid
  assign numvecValid$D_IN = MUX_numvecValid$write_1__SEL_1 ;
  assign numvecValid$EN =
	     vecState == 2'd2 && !count_2_ULT_16___d18 ||
	     WILL_FIRE_RL_finishResetCycle ;

  // register startReset
  assign startReset$D_IN = start_reset ;
  assign startReset$EN = 1'd1 ;

  // register vecState
  always@(MUX_dmaResetN$write_1__SEL_1 or
	  MUX_numvecValid$write_1__SEL_1 or
	  WILL_FIRE_RL_finishResetCycle or WILL_FIRE_RL_startResetCycle)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_dmaResetN$write_1__SEL_1: vecState$D_IN = 2'd2;
      MUX_numvecValid$write_1__SEL_1: vecState$D_IN = 2'd3;
      WILL_FIRE_RL_finishResetCycle: vecState$D_IN = 2'd0;
      WILL_FIRE_RL_startResetCycle: vecState$D_IN = 2'd1;
      default: vecState$D_IN = 2'b10 /* unspecified value */ ;
    endcase
  end
  assign vecState$EN =
	     vecState == 2'd1 && !count_2_ULT_128___d13 ||
	     vecState == 2'd2 && !count_2_ULT_16___d18 ||
	     WILL_FIRE_RL_finishResetCycle ||
	     WILL_FIRE_RL_startResetCycle ;

  // remaining internal signals
  assign count_2_ULT_128___d13 = count < 8'd128 ;
  assign count_2_ULT_16___d18 = count < 8'd16 ;

  // handling of inlined registers

  always@(posedge clk)
  begin
    if (resetn == `BSV_RESET_VALUE)
      begin
        count <= `BSV_ASSIGNMENT_DELAY 8'd0;
	dmaResetN <= `BSV_ASSIGNMENT_DELAY 1'd1;
	drpEn <= `BSV_ASSIGNMENT_DELAY 1'd0;
	drpRdy <= `BSV_ASSIGNMENT_DELAY 1'd0;
	drpState <= `BSV_ASSIGNMENT_DELAY 2'd0;
	drpWE <= `BSV_ASSIGNMENT_DELAY 1'd0;
	numvecDone <= `BSV_ASSIGNMENT_DELAY 1'd0;
	numvecValid <= `BSV_ASSIGNMENT_DELAY 1'd0;
	startReset <= `BSV_ASSIGNMENT_DELAY 1'd0;
	vecState <= `BSV_ASSIGNMENT_DELAY 2'd0;
      end
    else
      begin
        if (count$EN) count <= `BSV_ASSIGNMENT_DELAY count$D_IN;
	if (dmaResetN$EN) dmaResetN <= `BSV_ASSIGNMENT_DELAY dmaResetN$D_IN;
	if (drpEn$EN) drpEn <= `BSV_ASSIGNMENT_DELAY drpEn$D_IN;
	if (drpRdy$EN) drpRdy <= `BSV_ASSIGNMENT_DELAY drpRdy$D_IN;
	if (drpState$EN) drpState <= `BSV_ASSIGNMENT_DELAY drpState$D_IN;
	if (drpWE$EN) drpWE <= `BSV_ASSIGNMENT_DELAY drpWE$D_IN;
	if (numvecDone$EN)
	  numvecDone <= `BSV_ASSIGNMENT_DELAY numvecDone$D_IN;
	if (numvecValid$EN)
	  numvecValid <= `BSV_ASSIGNMENT_DELAY numvecValid$D_IN;
	if (startReset$EN)
	  startReset <= `BSV_ASSIGNMENT_DELAY startReset$D_IN;
	if (vecState$EN) vecState <= `BSV_ASSIGNMENT_DELAY vecState$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    count = 8'hAA;
    dmaResetN = 1'h0;
    drpEn = 1'h0;
    drpRdy = 1'h0;
    drpState = 2'h2;
    drpWE = 1'h0;
    numvecDone = 1'h0;
    numvecValid = 1'h0;
    startReset = 1'h0;
    vecState = 2'h2;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkQDMAConfigurator

